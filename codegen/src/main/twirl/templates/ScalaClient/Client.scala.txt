@*
 * Copyright (C) 2018-2021 Lightbend Inc. <https://www.lightbend.com>
 *@

@(service: akka.grpc.gen.scaladsl.Service)

@akka.grpc.gen.Constants.DoNotEditComment
package @service.packageName

// Not sealed so users can extend to write their stubs
@@akka.grpc.AkkaGrpcGenerated
trait @{service.name}Client extends @{service.name} with @{service.name}ClientPowerApi with akka.grpc.scaladsl.AkkaGrpcClient

@@akka.grpc.AkkaGrpcGenerated
object @{service.name}Client {
  def apply(settings: akka.grpc.GrpcClientSettings)(implicit sys: akka.actor.ClassicActorSystemProvider): @{service.name}Client =
    new Default@{service.name}Client(settings)
}

@@akka.grpc.AkkaGrpcGenerated
final class Default@{service.name}Client(settings: akka.grpc.GrpcClientSettings)(implicit sys: akka.actor.ClassicActorSystemProvider) extends @{service.name}Client {
  import @{service.name}.MethodDescriptors._

  private implicit val ex: scala.concurrent.ExecutionContext = sys.classicSystem.dispatcher
  private val options = akka.grpc.internal.NettyClientUtils.callOptions(settings)
  private val clientState = new akka.grpc.internal.ClientState(settings, akka.event.Logging(sys.classicSystem, classOf[Default@{service.name}Client]))

  @for(method <- service.methods) {
  private def @{method.name}RequestBuilder(channel: akka.grpc.internal.InternalChannel) =
  @if(method.methodType == akka.grpc.gen.Unary) {
    new akka.grpc.internal.ScalaUnaryRequestBuilder(@{method.name}Descriptor, channel, options, settings)
  } else {
    @if(method.methodType == akka.grpc.gen.ServerStreaming) {
    new akka.grpc.internal.ScalaServerStreamingRequestBuilder(@{method.name}Descriptor, channel, options, settings)
    } else if(method.methodType == akka.grpc.gen.ClientStreaming) {
    new akka.grpc.internal.ScalaClientStreamingRequestBuilder(@{method.name}Descriptor, channel, options, settings)
    } else if (method.methodType == akka.grpc.gen.BidiStreaming) {
    new akka.grpc.internal.ScalaBidirectionalStreamingRequestBuilder(@{method.name}Descriptor, channel, options, settings)
    }
  }
  }

  @for(method <- service.methods) {
  /**
   * Lower level "lifted" version of the method, giving access to request metadata etc.
   * prefer @{method.nameSafe}(@method.parameterType) if possible.
   */
  @if(method.methodType == akka.grpc.gen.Unary || method.methodType == akka.grpc.gen.ClientStreaming) {
  override def @{method.nameSafe}(): akka.grpc.scaladsl.SingleResponseRequestBuilder[@method.parameterType, @method.outputTypeUnboxed] =
    @{method.name}RequestBuilder(clientState.internalChannel)
  } else {
  override def @{method.nameSafe}(): akka.grpc.scaladsl.StreamResponseRequestBuilder[@method.parameterType, @method.outputTypeUnboxed] =
    @{method.name}RequestBuilder(clientState.internalChannel)
  }

  /**
   * For access to method metadata use the parameterless version of @{method.nameSafe}
   */
  def @{method.nameSafe}(in: @method.parameterType): @method.returnType =
    @{method.nameSafe}().invoke(in)
  }

  override def close(): scala.concurrent.Future[akka.Done] = clientState.close()
  override def closed: scala.concurrent.Future[akka.Done] = clientState.closed()

}

@@akka.grpc.AkkaGrpcGenerated
object Default@{service.name}Client {

  def apply(settings: akka.grpc.GrpcClientSettings)(implicit sys: akka.actor.ClassicActorSystemProvider): @{service.name}Client =
    new Default@{service.name}Client(settings)
}

@@akka.grpc.AkkaGrpcGenerated
trait @{service.name}ClientPowerApi {
  @for(method <- service.methods) {
  /**
   * Lower level "lifted" version of the method, giving access to request metadata etc.
   * prefer @{method.nameSafe}(@method.parameterType) if possible.
   */
  @if(method.methodType == akka.grpc.gen.Unary || method.methodType == akka.grpc.gen.ClientStreaming) {
  def @{method.nameSafe}(): akka.grpc.scaladsl.SingleResponseRequestBuilder[@method.parameterType, @method.outputTypeUnboxed] = ???
  } else {
  def @{method.nameSafe}(): akka.grpc.scaladsl.StreamResponseRequestBuilder[@method.parameterType, @method.outputTypeUnboxed] = ???
  }
  }

}
